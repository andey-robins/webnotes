Economics & Software Development
=====
Software Development came from the questions in the 60s about why software was so much more prone to failure than other traditional forms of creation and building.

An excellent allegory for it arises from the concept of "Tech Debt." When you're building a bridge, you can't simply decide what cars will drive across it at a later point because it's more fun/is more visible/is a bigger priority to sink the pylons into the river bed. You have to design an entire bridge from the ground up first, get it's design signed off upon, and then you can begin to build.

My own musings and remembering from Software Design as a course is that the Waterfall method is excellent at building the system you needed from the beginning. Its major failing is that it doesn't allow you to adapt at the speed software is required to adapt.

## First Generation Lessons
1. Huge, huge, huge variation in productivity of individuals
2. Largest gains come from using an appropriately high-level langauge
3. High-level languages take away accidental complexity so that developers can focus on the intrinsic complexity of the systems
4. More time spent developing specs leads to far less time coding and testing

The best way forward is modularization. Instead of building complex systems, we're creating small systems that then have to interact and talk to each other.